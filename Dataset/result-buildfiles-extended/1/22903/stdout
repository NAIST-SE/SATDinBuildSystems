{
  "Repository" : "22903",
  "Revision" : "HEAD",
  "ObjectId" : "c3b89fe567f4442cf5c6351b66a435d8cfff09d4",
  "CommitTime" : "2019-04-09T09:25:22Z",
  "Files" : {
    "docs/Makefile" : {
      "ObjectId" : "87f9e28607eba12cba05628479a175e490d98303",
      "LastModified" : "2014-06-30T01:54:08Z",
      "FileType" : "MAKEFILE",
      "0" : {
        "Text" : "# Makefile for Sphinx documentation\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# You can set these variables from the command line.\n",
        "Line" : 4,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# User-friendly check for sphinx-build\n",
        "Line" : 10,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# Internal variables.\n",
        "Line" : 15,
        "CharPositionInLine" : 0
      },
      "4" : {
        "Text" : "# the i18n builder cannot share the environment and doctrees with the others\n",
        "Line" : 19,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 5
    },
    "example_packages/hello_world/CMakeLists.txt" : {
      "ObjectId" : "d8dd8786fa1a6cb335a675d3c3582c9ddf558a7a",
      "LastModified" : "2016-07-31T21:22:12Z",
      "FileType" : "CMAKE",
      "CommentCount" : 0
    },
    "src/rez/tests/data/builds/packages/hello/1.0/Makefile" : {
      "ObjectId" : "7ffb0f12d0683f7a102c6e5895c8810a899c6bb4",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "MAKEFILE",
      "CommentCount" : 0
    },
    "src/rez/tests/data/builds/packages/sup_world/3.8/CMakeLists.txt" : {
      "ObjectId" : "39d77262b378c9c298918b602abf897e94eccea8",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "CommentCount" : 0
    },
    "src/rez/tests/data/builds/packages/sup_world/3.8/lib/CMakeLists.txt" : {
      "ObjectId" : "2da56c6863c1350e7988adfd42ec397af05c5ba6",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# if we were using boost, you might see something like this\n\n# set(boost_COMPONENTS thread system)\n",
        "Line" : 3,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# build and install lib\n",
        "Line" : 8,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# install the headers\n",
        "Line" : 14,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 3
    },
    "src/rez/tests/data/builds/packages/sup_world/3.8/util/CMakeLists.txt" : {
      "ObjectId" : "9d72f76a2e60ff4523e1c1eea03aee73b075b5f8",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# expose local lib\n",
        "Line" : 5,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# build and install executable\n",
        "Line" : 9,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 2
    },
    "src/rez/tests/data/builds/packages/translate_lib/2.2.0/CMakeLists.txt" : {
      "ObjectId" : "8dbe11d5fd72568b726d61f19673dd67e9a843fb",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# build/install lib\n",
        "Line" : 7,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# install headers\n",
        "Line" : 13,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# install cmake file\n",
        "Line" : 21,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 3
    },
    "src/rezplugins/build_system/cmake_files/Colorize.cmake" : {
      "ObjectId" : "1cbe39014e0a85e5148a8f00e8eb371fff873926",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# Convenience variables to add colour to the MESSAGE output provided by CMake.\n\n# These variables make use of standard terminal escape sequences.  This only\n\n# affects the output during the cmake configuration step, and not execution of\n\n# Makefiles etc.\n\n#\n\n# The MESSAGE command is redefined here to ensure all CMake generated messages\n\n# are colorized by default.\n\n#\n\n# This implementation is taken from the answer given by 'Fraser' in\n\n# http://stackoverflow.com/questions/18968979/how-to-get-colorized-output-with-cmake\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# segfault if this file is included more than once... :/\n",
        "Line" : 12,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# for the Americans\n",
        "Line" : 20,
        "CharPositionInLine" : 35
      },
      "CommentCount" : 3
    },
    "src/rezplugins/build_system/cmake_files/FindStaticLibs.cmake" : {
      "ObjectId" : "a4d0dd7960171760c04163e1098baf05d299f243",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# This is a utility function to get around problems when using pkg-config in combination with static\n\n# library linking. Cmake has a 'pkg_check_modules' function, which runs pkgconfig and returns the\n\n# results in a set of variables, one being <PREFIX>_LIBRARIES. However, if a library has both static\n\n# and dynamic libs available, the libraries returned to cmake will be expanded by cmake into the\n\n# dynamic libraries, not the static ones, even if pkgconfig has been invoked with its '--static'\n\n# option. In truth pkgconfig shares some of the blame - the '--static' option just includes the libs\n\n# in the 'Libs.private' section of the .pc file, and does nothing else.\n\n#\n\n# This macro takes a list of library search paths, and a list of libraries with no path or extension,\n\n# and returns the same list of library names, but with a '.a' appended to those where a static\n\n# version of the library was found in the library paths.\n\n#\n\n# We expect a list of library names (minus path or extension) because this is how cmake converts\n\n# pkgconfig's '--libs' output into a list of libraries (basically - -lXXX strings with '-l' removed).\n\n# And those libs that are static have '.a' appended, because on passing these to cmake's\n\n# target_link_libraries() function, it knows they are static and creates the appropriate ldflags.\n\n#\n\n# Notes:\n\n# Absolute path libs are left unchanged.\n\n#\n\n# Eg of usage:\n\n#\n\n# pkg_check_modules(pkgs REQUIRED foo)\n\n# message(${pkgs_LIBRARIES})\n\n# find_static_libs(pkgs_LIBRARY_DIRS pkgs_LIBRARIES outvar)\n\n# message(${outvar})\n\n#\n\n# This might produce the messages:\n\n#\n\n# fooCore fooUtil\n\n# fooCore.a fooUtil.a\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# stop find_file caching result\n",
        "Line" : 40,
        "CharPositionInLine" : 12
      },
      "CommentCount" : 2
    },
    "src/rezplugins/build_system/cmake_files/InstallDirs.cmake" : {
      "ObjectId" : "21475ee9f1cf380776c9962aec05be843231e314",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# install_dirs_\n\n# rez_install_dirs\n\n#\n\n# Macro for installing directories. Very similar to cmake's native install(DIRECTORY), but\n\n# is more convenient to use. Files are installed as read-only. svn files (any file within\n\n# a .svn dir) are excluded. If this macro does not provide enough fine-grain control for\n\n# your needs, then you should use cmake's install(DIRECTORY) macro instead (and you should\n\n# use the values REZ_FILE_INSTALL_PERMISSIONS and REZ_EXECUTABLE_FILE_INSTALL_PERMISSIONS\n\n# to specify the permissions you want).If LOCAL_SYMLINK is preset it would create a symlink\n\n# from the build package back to the source code for development/testing purposes. That way\n\n# a rez-build is not needed every time that the code changes.\n\n#\n\n# Usage: install_dirs_(\n\n#\t<directories>\n\n#\tDESTINATION <rel_install_dir>\n\n#\t[EXECUTABLE]\n\n#\t[LOCAL_SYMLINKS]\n\n# )\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# there isn't anything rez-specific here, but this matches name convention on other macros\n",
        "Line" : 25,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "#\n\n# parse args\n\n#\n",
        "Line" : 33,
        "CharPositionInLine" : 1
      },
      "CommentCount" : 3
    },
    "src/rezplugins/build_system/cmake_files/InstallFiles.cmake" : {
      "ObjectId" : "dfdeec2b6a5977796ef1fedc8dec65eefb55e1e5",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# install_files_\n\n# rez_install_files\n\n#\n\n# Macro for installing files. Unlike cmake's native 'install(FILES ...)' command,\n\n# this macro preserves directory structure. Don't confuse with cmake's deprecated\n\n# 'install_files' function. Files are installed as read-only.\n\n#\n\n# Usage: install_files_(\n\n#\t<files> [RELATIVE <rel_path>]\n\n#\tDESTINATION <rel_install_dir>\n\n#\t[EXECUTABLE]\n\n#   [LOCAL_SYMLINK]\n\n# )\n\n#\n\n# 'files' can be relative or absolute. Subdirectories are copied intact. RELATIVE lets\n\n# you remove some of the file's relative path before it is installed. Note however that\n\n# ALL files must be within the RELATIVE path, if RELATIVE is specified. If EXECUTABLE is\n\n# present then the files will be installed with execute permissions. If LOCAL_SYMLINK\n\n# is present it will create a symlink from the build package back to the source code\n\n# for development/testing purposes. That way it is not necessary to do a rez-build every\n\n# time the code changes.\n\n#\n\n# Example - take the files:\n\n#\n\n# - CMakeLists.txt\n\n# - data/foo.a\n\n# - data/detail/bah.a\n\n#\n\n# The command:\n\n# install_files_(data/foo.a data/detail/bah.a DESTINATION mydata)\n\n# will install files to:\n\n# - <INSTALLDIR>/mydata/data/foo.a\n\n# - <INSTALLDIR>/mydata/data/detail/bah.a\n\n#\n\n# install_files_(data/foo.a data/detail/bah.a DESTINATION .)\n\n# will install files to:\n\n# - <INSTALLDIR>/data/foo.a\n\n# - <INSTALLDIR>/data/detail/bah.a\n\n#\n\n# install_files_(data/foo.a data/detail/bah.a RELATIVE data DESTINATION int)\n\n# will install files to:\n\n# - <INSTALLDIR>/int/foo.a\n\n# - <INSTALLDIR>/int/detail/bah.a\n\n#\n\n# install_files_(data/foo.a data/detail/bah.a RELATIVE data DESTINATION .)\n\n# will install files to:\n\n# - <INSTALLDIR>/foo.a\n\n# - <INSTALLDIR>/detail/bah.a\n\n#\n\n# install_files_(data/foo.a data/detail/bah.a RELATIVE data DESTINATION . LOCAL_SYMLINK )\n\n# will create a symlink from:\n\n# - <INSTALLDIR>/foo.a --> <SOURCEDIR>/foo.a\n\n# - <INSTALLDIR>/detail/bah.a --><SOURCEDIR>/detail/bah.a\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# there isn't anything rez-specific here, but this matches name convention on other macros\n",
        "Line" : 59,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "##########################################################################################\n\n# get_target_filepath\n\n##########################################################################################\n",
        "Line" : 65,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# This is a helper macro which calculates the install location for the given file. 'filepath'\n\n# is the file in question, relative to the current source directory. 'result' is set to the\n\n# install location. This includes the filename, but not the absolute install directory.\n",
        "Line" : 69,
        "CharPositionInLine" : 0
      },
      "4" : {
        "Text" : "# cmake file(RELATIVE_PATH) is broken, only reason this is here\n",
        "Line" : 74,
        "CharPositionInLine" : 1
      },
      "5" : {
        "Text" : "##########################################################################################\n\n# install_files_\n\n##########################################################################################\n",
        "Line" : 96,
        "CharPositionInLine" : 0
      },
      "6" : {
        "Text" : "#\n\n# parse args\n\n#\n",
        "Line" : 102,
        "CharPositionInLine" : 1
      },
      "7" : {
        "Text" : "#\n\n# install files\n\n#\n",
        "Line" : 129,
        "CharPositionInLine" : 1
      },
      "CommentCount" : 8
    },
    "src/rezplugins/build_system/cmake_files/InstallPython.cmake" : {
      "ObjectId" : "31d030509cc7a3555273870793fe158f4cbdc1cd",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# install_python\n\n#\n\n# Macro for building and installing python files.\n\n#\n\n# Usage:\n\n# install_python(\n\n#\t<label>\n\n#\tFILES <py_files>\n\n#\t[RELATIVE <rel_path>]\n\n#\t[BIN <py_binary>]\n\n#   [LOCAL_SYMLINK]\n\n#\tDESTINATION <rel_install_dir>)\n\n#\n\n# 'label' is the cmake build target name for this set of python files.\n\n#\n\n# 'py_files' are the python scripts you wish to install.\n\n#\n\n# 'bin' is the python binary to use. If supplied, the python files are compiled (but not\n\n# installed), to check for syntax errors.\n\n#\n\n# This macro behaves in the same way as rez_install_files with respect to the arguments\n\n# RELATIVE, DESTINATION and LOCAL_SYMLINK - please see InstallFiles.cmake documentation\n\n# for further information.\n\n#\n\n# A note on the use of LOCAL_SYMLINK: If set, pyc files are not generated.\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# --------------------------------------------------------------------------\n\n# parse args\n\n# --------------------------------------------------------------------------\n",
        "Line" : 36,
        "CharPositionInLine" : 1
      },
      "2" : {
        "Text" : "# cancel compiling if local symlinking enabled\n",
        "Line" : 67,
        "CharPositionInLine" : 1
      },
      "3" : {
        "Text" : "# --------------------------------------------------------------------------\n\n# install .py's and .pyc's\n\n# --------------------------------------------------------------------------\n",
        "Line" : 74,
        "CharPositionInLine" : 1
      },
      "4" : {
        "Text" : "# ------------------------------------------------------------------\n\n# py file\n\n# ------------------------------------------------------------------\n",
        "Line" : 92,
        "CharPositionInLine" : 3
      },
      "5" : {
        "Text" : "# ------------------------------------------------------------------\n\n# pyc file\n\n# ------------------------------------------------------------------\n",
        "Line" : 99,
        "CharPositionInLine" : 3
      },
      "CommentCount" : 6
    },
    "src/rezplugins/build_system/cmake_files/RezBuild.cmake" : {
      "ObjectId" : "0173177b977842c737b8b2d63a9154af88d1a399",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# This module should be included for projects built within a rez-build context. Several macros are made\n\n# available (see those cmake filse for details): rez_find_packages, rez_install_cmake and rez_install_python.\n\n#\n\n# Including this file will implicitly call the cmake function project(<package_name>) for you.\n\n#\n\n# Output variables:\n\n#\n\n# For the current package, and each package in the current build variant:\n\n# <PKG>_VERSION\n\n# <PKG>_MAJOR_VERSION\n\n# <PKG>_MINOR_VERSION\n\n# <PKG>_PATCH_VERSION\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "#############################################################################\n\n# make sure we're within a rez-build context\n\n#############################################################################\n",
        "Line" : 16,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "#############################################################################\n\n# setup rez-build system variables\n\n#############################################################################\n",
        "Line" : 27,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# list of all packages used by this build\n",
        "Line" : 42,
        "CharPositionInLine" : 0
      },
      "4" : {
        "Text" : "# move all package versions into <pkg>_VERSION variables so client CMakeLists.txt can use them.\n\n# also generates <pkg>_MAJOR_VERSION etc variables, in case they are needed.\n",
        "Line" : 46,
        "CharPositionInLine" : 0
      },
      "5" : {
        "Text" : "#############################################################################\n\n# include rez-build- related cmake modules\n\n#############################################################################\n",
        "Line" : 69,
        "CharPositionInLine" : 0
      },
      "6" : {
        "Text" : "#include(RezInstallDoxygen)\n",
        "Line" : 81,
        "CharPositionInLine" : 0
      },
      "7" : {
        "Text" : "#############################################################################\n\n# installation setup\n\n#############################################################################\n",
        "Line" : 84,
        "CharPositionInLine" : 0
      },
      "8" : {
        "Text" : "#############################################################################\n\n# Automatic build and install actions\n\n#############################################################################\n",
        "Line" : 91,
        "CharPositionInLine" : 0
      },
      "9" : {
        "Text" : "#\n\n# Set C++ Cflags/LDflags based on rez-cmake flags such as -o\n\n#\n",
        "Line" : 97,
        "CharPositionInLine" : 0
      },
      "10" : {
        "Text" : "#############################################################################\n\n# utility macros\n\n#############################################################################\n",
        "Line" : 107,
        "CharPositionInLine" : 0
      },
      "11" : {
        "Text" : "# This macro sets the variable named by result equal to TRUE if 'pkg_string' is\n\n# the unversioned name of any package being used in the current build variant.\n",
        "Line" : 111,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 12
    },
    "src/rezplugins/build_system/cmake_files/RezFindPackages.cmake" : {
      "ObjectId" : "9a78d028923c16a7e3b6bd7d4aaa103d2a6cb40e",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# macro:\n\n# rez_find_packages\n\n#\n\n# ------------------------------\n\n# Overview\n\n# ------------------------------\n\n#\n\n# usage:\n\n# find_rez_package([package1 package2 .. packageN] [PREFIX prefix] [REQUIRED] [AUTO])\n\n# where 'packageN' is an UNVERSIONED package name (eg 'boost')\n\n#\n\n# This macro attempts to find the listed packages, and combines the resulting cflags and\n\n# ldflags into output variables. If no packages are listed, then all packages used by the\n\n# current build variant is implied. If AUTO is specified, then include dirs, library dirs\n\n# and definitions (extra cflags) are automatically set via cmake native functions\n\n# include_directories(), link_directories(), add_definitions().\n\n#\n\n# INCLUDE_DIRS_NO_SYSTEM can be set to disable the declaration of INCLUDE_DIRS\n\n# as SYSTEM.\n\n#\n\n# ------------------------------\n\n# Finding a Package\n\n# ------------------------------\n\n#\n\n# For each package, we first attempt to include the file <package>.cmake. If this file does not\n\n# exist, then we attempt to invoke 'pkg-config <package>'. If the package does not have a .pc\n\n# file, then we silently skip this package, unless REQUIRES is specified, in which case an\n\n# error results. Packages expose their cmake modules/pc files by providing commands in their\n\n# package.yamls which append to CMAKE_MODULE_PATH/PKG_CONFIG_PATH appropriately.\n\n#\n\n# If a package provides a cmake module, then the module must return these variables:\n\n# <package>_INCLUDE_DIRS, <package>_LIBRARY_DIRS, <package>_LIBRARIES, <package>_DEFINITIONS\n\n#\n\n# If a package provides a .pc file, then the relevant output vars are generated automatically.\n\n#\n\n# ------------------------------\n\n# Components\n\n# ------------------------------\n\n#\n\n# It is common for a package to provide 'components' to use, usually these represent separate\n\n# libraries within the package that can be optionally linked to. Package cmake modules should\n\n# expect the input variable <package>_COMPONENTS to list the desired components, if any, and\n\n# should take appropriate action.\n\n#\n\n# In the case of packages that provide .pc files, they are expected to provide\n\n# <package>_<component>.pc files for each provided component, as well as a base <package>.pc as\n\n# usual.\n\n#\n\n# ------------------------------\n\n# Static Linking\n\n# ------------------------------\n\n#\n\n# Package libraries are assumed to be linked dynamically by default. To enable static linking\n\n# of a package, the input variable <package>_STATIC is expected, and is usually set to ON or\n\n# OFF. Packages' cmake modules should expect this variable if they support static linking. For\n\n# packages with .pc files, ### TODO THIS IS DIFFICULT AND THERE IS NO NATIVE SUPPORT :( ###\n\n#\n\n# ------------------------------\n\n# Return Values\n\n# ------------------------------\n\n#\n\n# Each packages' output variables are combined into the following variables:\n\n# <PREFIX>_INCLUDE_DIRS\n\n# <PREFIX>_SYSTEM_INCLUDE_DIRS\n\n# <PREFIX>_LIBRARY_DIRS\n\n# <PREFIX>_LIBRARIES\n\n# <PREFIX>_DEFINITIONS\n\n#\n\n# ------------------------------\n\n# Notes\n\n# ------------------------------\n\n#\n\n# - debug/release not thought about yet\n\n# - static/dynamic linking not thought about on pkgconfig files support yet\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# parse args\n\n#--------------------------------------------------------------------\n",
        "Line" : 93,
        "CharPositionInLine" : 1
      },
      "2" : {
        "Text" : "# no pkgs listed means use all packages\n",
        "Line" : 103,
        "CharPositionInLine" : 1
      },
      "3" : {
        "Text" : "# iterate over packages\n\n#--------------------------------------------------------------------\n",
        "Line" : 115,
        "CharPositionInLine" : 1
      },
      "4" : {
        "Text" : "# note: this happens to work because CMAKE_MODULE_PATH is semicolon-delimited,\n\n# it is just coincidence that cmake will read this as being a list\n",
        "Line" : 119,
        "CharPositionInLine" : 1
      },
      "5" : {
        "Text" : "# cmake module found\n\n# ----------------------\n",
        "Line" : 125,
        "CharPositionInLine" : 2
      },
      "6" : {
        "Text" : "# pull in the module, this should define the pkg_XXX output vars\n",
        "Line" : 128,
        "CharPositionInLine" : 2
      },
      "7" : {
        "Text" : "# pkgconfig file found\n\n# ----------------------\n",
        "Line" : 163,
        "CharPositionInLine" : 3
      },
      "8" : {
        "Text" : "# select components as well\n",
        "Line" : 169,
        "CharPositionInLine" : 3
      },
      "9" : {
        "Text" : "# run pkgconfig and gather flags\n",
        "Line" : 183,
        "CharPositionInLine" : 3
      },
      "10" : {
        "Text" : "# remove duplicate flags\n\n#--------------------------------------------------------------------\n",
        "Line" : 224,
        "CharPositionInLine" : 1
      },
      "11" : {
        "Text" : "# remove duplicate cflags - don't do this for ldflags, there can be subtle cases wrt static linking\n\n# where duplicates are necessary.\n",
        "Line" : 227,
        "CharPositionInLine" : 1
      },
      "12" : {
        "Text" : "#list(REMOVE_DUPLICATES ${DFP_PREFIX}_INCLUDE_DIRS)\n",
        "Line" : 230,
        "CharPositionInLine" : 1
      },
      "13" : {
        "Text" : "# apply what we can\n\n#--------------------------------------------------------------------\n",
        "Line" : 235,
        "CharPositionInLine" : 1
      },
      "14" : {
        "Text" : "# add cflags, escaping quotes along the way. add_definitions() will do this for you, however\n\n# non-define flags passed to add_definitions() are not picked up and passed to gcc by FindCUDA\n\n# macros. Similar problems may exist in other macros.\n",
        "Line" : 243,
        "CharPositionInLine" : 2
      },
      "CommentCount" : 15
    },
    "src/rezplugins/build_system/cmake_files/RezInstallCMake.cmake" : {
      "ObjectId" : "45d3cccbce15e3dcc49579b84b58ca808a70f70b",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# rez_install_cmake\n\n#\n\n# Macro for building and installing the cmake file for a project. The installed\n\n# file will be called <unversioned_package_name>.cmake. This generated file will\n\n# then be included by other projects using this one, via the 'rez_find_packages'\n\n# macro. Note that, if using this macro, you should have a line in your package.yaml\n\n# which includes the cmake file in CMAKE_MODULE_PATH, eg:\n\n# - export CMAKE_MODULE_PATH=$CMAKE_MODULE_PATH:!ROOT!/cmake\n\n#\n\n# Arguments:\n\n#\n\n# DEFAULT ARG: AUTO - if enabled, rez will attempt to discover the\n\n#               standard locations for each named argument.  Named\n\n#               arguments will override this automatic discovery.\n\n#\n\n# DESTINATION: \trelative subdirectory to install the cmake file into.\n\n#\n\n# INCLUDE_DIRS: include directories. Any entries that are non-absolute paths are\n\n# \t\t\t\tassumed to be a subdirectory of this package install.\n\n#\n\n# LIBRARY_DIRS: library directories. Any entries that are non-absolute paths are\n\n# \t\t\t\tassumed to be a subdirectory of this package install.\n\n#\n\n# LIBRARIES: \tlibraries to link against.\n\n#\n\n# DEFINITIONS: \textra cflags.\n\n#\n\n# CUSTOM_STRING: Any additional data to be written to the cmake file.\n\n#\n\n# USE_SYSTEM_INCLUDE_DIRS: When used with rez_find_packages, this flag will\n\n#               cause the INCLUDE_DIRS of this package to be declared as SYSTEM\n\n#               directories, removing warnings etc at compile time.\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "#\n\n# res_install_cmake specific utility macros\n\n#\n",
        "Line" : 41,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# Append a directory to relative paths found in input_dirs\n",
        "Line" : 45,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# Use a temporary variable to allow input_dirs to be the same\n\n# variable as output_dirs, for in-line replacement\n",
        "Line" : 47,
        "CharPositionInLine" : 1
      },
      "4" : {
        "Text" : "# Find libraries for the given type\n\n# lib_type :\n\n#\tThe type of libraries to look for. Must be DYNAMIC, STATIC, or ALL.\n\n#\n\n# library_dirs :\n\n# \tThe directories to search for libraries in.\n\n#\n\n# output_libraries\n\n#   The variable to save the results to.\n",
        "Line" : 61,
        "CharPositionInLine" : 0
      },
      "5" : {
        "Text" : "#\n\n# parse args\n\n#\n",
        "Line" : 96,
        "CharPositionInLine" : 1
      },
      "6" : {
        "Text" : "#\n\n# Test required arguments\n",
        "Line" : 105,
        "CharPositionInLine" : 1
      },
      "7" : {
        "Text" : "# Defer cmake file creation until after install, so that if do_auto is\n\n# true, it will be able to correctly find the installed libraries.\n\n#\n\n# We always defer this macro, because it keeps the code succinct.\n\n# NOTE: this does somewhat break backward compatibility in that\n\n# \t    the cmake file is never written to the build directory.\n",
        "Line" : 113,
        "CharPositionInLine" : 1
      },
      "8" : {
        "Text" : "#\n\n# parse args\n\n#\n",
        "Line" : 136,
        "CharPositionInLine" : 1
      },
      "9" : {
        "Text" : "#\n\n# Populate auto arguments\n\n#\n",
        "Line" : 151,
        "CharPositionInLine" : 1
      },
      "10" : {
        "Text" : "#\n\n# point non-absolute paths at the install dir for this package\n\n#\n",
        "Line" : 166,
        "CharPositionInLine" : 2
      },
      "11" : {
        "Text" : "# Report to the user that the cmake script is being installed, and where\n\n# In order to do this properly, we must first make the directory where\n\n# cmake will be installed\n",
        "Line" : 172,
        "CharPositionInLine" : 1
      },
      "12" : {
        "Text" : "#\n\n# process non-absolute paths to point at the install dir for this package\n\n#\n",
        "Line" : 182,
        "CharPositionInLine" : 1
      },
      "13" : {
        "Text" : "# Find all library names/paths\n",
        "Line" : 195,
        "CharPositionInLine" : 1
      },
      "14" : {
        "Text" : "# Find the libraries.\n",
        "Line" : 199,
        "CharPositionInLine" : 5
      },
      "15" : {
        "Text" : "# Format them for writing to file.\n",
        "Line" : 208,
        "CharPositionInLine" : 2
      },
      "16" : {
        "Text" : "#\n\n# generate the cmake file\n\n#\n",
        "Line" : 230,
        "CharPositionInLine" : 1
      },
      "17" : {
        "Text" : "# This won't be made with the correct permissions.  Not sure how to fix this.\n\n# PERMISSIONS ${REZ_FILE_INSTALL_PERMISSIONS}\n",
        "Line" : 234,
        "CharPositionInLine" : 1
      },
      "CommentCount" : 18
    },
    "src/rezplugins/build_system/cmake_files/RezInstallContext.cmake" : {
      "ObjectId" : "077300227208ee40b6e8e614795feea680392c03",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# rez_install_context\n\n#\n\n# This macro takes the same information that rez-config itself does (ie resolution\n\n# mode, packages) and creates and installs a context file (including supporting\n\n# files - .dot).\n\n#\n\n# 'label': just a name for the target which builds the context file.\n\n#\n\n# 'target': name of the context file to generate.\n\n#\n\n# MODE: resolution mode [default: latest]\n\n#\n\n# PACKAGES: packages in the context.\n\n#\n\n# DESTINATION: relative directory where context file will be installed to.\n\n#\n\n# EXTRA_COMMANDS: extra bash commands, will be added to the end of the context\n\n#\n\n# Usage:\n\n# rez_install_context(<label> <target>\n\n#\t[MODE earliest|latest] [default=latest]\n\n#\tPACKAGES pkg1 pkg2 ... pkgN\n\n#\tDESTINATION <target_dir>\n\n#\t[EXTRA_COMMANDS cmd1 cmd2 ... cmdN] )\n\n#\n\n# Eg:\n\n# rez_install_context(\n\n#\tcontext\n\n#\tfoo.context\n\n#\tMODE latest\n\n#\tPACKAGES houdini-11 boost-1.37.0 rv\n\n#\tDESTINATION .\n\n# )\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "#\n\n# parse args\n\n#\n",
        "Line" : 42,
        "CharPositionInLine" : 1
      },
      "2" : {
        "Text" : "#\n\n# build and install context.\n\n#\n",
        "Line" : 73,
        "CharPositionInLine" : 1
      },
      "CommentCount" : 3
    },
    "src/rezplugins/build_system/cmake_files/RezInstallDoxygen.cmake" : {
      "ObjectId" : "f8138cefe6f489c14296dde1572f467f1787c236",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# rez_install_doxygen\n\n#\n\n# Macro for building and installing doxygen files for rez projects. Take special note of the\n\n# DOXYPY option if you want to build docs for python source.\n\n#\n\n# Usage:\n\n# rez_install_doxygen(\n\n#\t<label>\n\n#\tFILES <files>\n\n#\tDESTINATION <rel_install_dir>\n\n#\t[DOXYFILE <doxyfile>]\n\n#\t[DOXYDIR <dir>]\n\n#\t[IMAGEPATH <dir>]\n\n#   [FORCE]\n\n#\t[DOXYPY]\n\n# )\n\n#\n\n# <label>: This becomes the name of this cmake target. Eg 'doc'.\n\n# DESTINATION: Relative path to install resulting docs to. Typically Doxygen will create a \n\n# directory (often 'html'), which is installed into <install_path>/<rel_install_dir>/html.\n\n#\n\n# DOXYFILE: The doxygen config file to use. If unspecified, Rez will use its own default config.\n\n#\n\n# DOXYDIR: The directory the docs will be generated in, defaults to 'html'. You only need to set\n\n# this if you're generating non-html output (for eg, by setting GENERATE_HTML=NO in a custom Doxyfile).\n\n#\n\n# IMAGEPATH: The directory that images are found in.\n\n#\n\n# FORCE: Normally docs are not installed unless a central installation is taking place - set this\n\n# arg to force doc building and installation always.\n\n#\n\n# DOXYPY: At the time of writing, Doxygen does not have good python support. A separate, GPL project\n\n# called 'doxypy' (http://code.foosel.org/doxypy) can be used to fix this - it lets you write \n\n# doxygen-style comments in python docstrings, and extracts them correctly. Doxypy cannot be shipped\n\n# with Rez since its license is incompatible - in order to use it, Rez expects you to install it \n\n# yourself, and then make it available by binding it to Rez (as you would any 3rd party software) \n\n# as a package called 'doxypy', with the doxypy.py file in the package root. Once you've done this,\n\n# and you specify the DOXYPY option, you get complete python Doxygen support (don't forget to include\n\n# the doxypy package as a build_requires). You can then comment your python code in doxygen style, \n\n# like so:\n\n#\n\n# def myFunc(foo):\n\n#   \"\"\"\n\n#   @param foo The foo.\n\n#   @return Something foo-like.\n\n#   \"\"\"\n\n#\n\n# Note: Consider adding a rez-help entry to your package.yaml like so:\n\n# help: firefox file://!ROOT!/<DESTINATION>/<DOXYDIR>/index.html\n\n# Then, users can just go \"rez-help <pkg>\", and the doxygen help will appear.\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "#COMMAND ${DOXYGEN_EXECUTABLE}\n",
        "Line" : 149,
        "CharPositionInLine" : 3
      },
      "2" : {
        "Text" : "# only install docs when installing centrally\n",
        "Line" : 156,
        "CharPositionInLine" : 3
      },
      "CommentCount" : 3
    },
    "src/rezplugins/build_system/cmake_files/RezInstallPython.cmake" : {
      "ObjectId" : "6f624ab982d086e63544d2f1a73df324bc006e26",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# rez_install_python\n\n#\n\n# Macro for building and installing python files for rez projects. This is the same as install_python,\n\n# except that it ensures that a python package is being used, and uses the appropriate python binary.\n\n#\n\n# Usage:\n\n# rez_install_python(<label>\n\n#                    FILES <py_files>\n\n#                    [RELATIVE <rel_path>]\n\n#                    [LOCAL_SYMLINK]\n\n#                    DESTINATION <rel_install_dir>)\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "#\n\n# check that 'python' is in the environment. All 'python' packages should expose a 'rez-python'\n\n# binary (whether that be symlink/wrapper script etc), the following build command relies\n\n# on this, so that the correct version of the python interpreter is used to compile.\n\n#\n",
        "Line" : 27,
        "CharPositionInLine" : 1
      },
      "CommentCount" : 2
    },
    "src/rezplugins/build_system/cmake_files/RezPipInstall.cmake" : {
      "ObjectId" : "eca70c20a71acf9b6f30b9afa697fe06f7d36ec8",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# rez_pip_install\n\n#\n\n# Macro for installing python modules using pip.\n\n#\n\n# By default, the macro will install the package payload (.py, .pyc, .so etc\n\n# files) into {root}/python, and any binaries into {root}/bin. You can provide\n\n# PYTHONDIR and/or BINDIR to override this behavior.\n\n#\n\n# URL is the same url you would pass to pip - this can be an http url, or the\n\n# filepath of a local archive (typically a tar.gz file).\n\n#\n\n# Pip args will be passed directly to pip when it runs the install. useful for verbosity\n\n# or when defining custom include paths from other package in rez\n\n#\n\n# Usage:\n\n# rez_pip_install(\n\n#   <label>\n\n#   URL <url>\n\n#   [PYTHONDIR <pydir>]  # (default: 'python')\n\n#   [BINDIR <bindir>]  # (default: 'bin')\n\n#   [PIPARGS <pipargs>] # (default: '')\n\n# )\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# --------------------------------------------------------------------------\n\n# parse args\n\n# --------------------------------------------------------------------------\n",
        "Line" : 35,
        "CharPositionInLine" : 4
      },
      "2" : {
        "Text" : "# --------------------------------------------------------------------------\n\n# build/install\n\n#\n\n# Note: a 'build' is really just an install to a local staging directory.\n\n# --------------------------------------------------------------------------\n",
        "Line" : 77,
        "CharPositionInLine" : 4
      },
      "3" : {
        "Text" : "# PIP on Windows doesn't like forward slashes for the --install-scripts argument\n",
        "Line" : 97,
        "CharPositionInLine" : 4
      },
      "4" : {
        "Text" : "# Note the lack of double quotes where you would expect around --install-scripts=.\n\n# CMake escapes the quotes if I try; fortunately it works without.\n\n#\n",
        "Line" : 114,
        "CharPositionInLine" : 12
      },
      "CommentCount" : 5
    },
    "src/rezplugins/build_system/cmake_files/RezProject.cmake" : {
      "ObjectId" : "54143766a9186d06a0369e54637de7857f675708",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# macro:\n\n# rez_project\n\n#\n\n# Use this macro in lieu of cmake's native 'project' macro, when writing projects\n\n# that use rez-build. The project name is not an argument to the macro - it is\n\n# read from the package.py instead.\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# As a Windows compiler and build environment isn't correctly setup (yet),\n\n# stop CMake performing automatic compiler discovery (and failing).\n",
        "Line" : 12,
        "CharPositionInLine" : 4
      },
      "CommentCount" : 2
    },
    "src/rezplugins/build_system/cmake_files/RezRepository.cmake" : {
      "ObjectId" : "56ec2006b3d70b917f8659eb330442b9c8cd461a",
      "LastModified" : "2017-05-11T00:59:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "#\n\n# macro:\n\n# rez_set_archive\n\n#\n\n# usage:\n\n# rez_set_archive(variable RELATIVE_PATH URL)\n\n#\n\n# This macro checks for the existence of a file at the given relative path, under\n\n# the path specified by the environment variable $REZ_REPO_PAYLOAD_DIR. This\n\n# file is typically a source archive, such as a .tgz.\n\n#\n\n# If the file doesn't exist, an error is raised. If it does, the path is written\n\n# to 'variable'.\n\n#\n\n# This macro is used by many of the packages found in the 'repository' directory.\n\n#\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 1
    },
    "src/rezplugins/build_system/cmake_files/Utils.cmake" : {
      "ObjectId" : "a1ca683f7cb28ee03fc67501195ffd835385b0f9",
      "LastModified" : "2018-01-09T01:30:05Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# This utility macro converts a list into a space-separated string.\n\n# Really this should be native to cmake\n",
        "Line" : 2,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# This utility macro determines whether a particular string value\n\n# occurs within a list of strings:\n\n#\n\n#  list_contains(result string_to_find arg1 arg2 arg3 ... argn)\n\n#\n\n# This macro sets the variable named by var equal to TRUE if\n\n# string_to_find is found anywhere in the following arguments.\n",
        "Line" : 13,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# This utility macro strips out items of the list that match\n\n# the given regular expression\n\n#\n\n#  list_remove_regex(listvar regex)\n\n#\n",
        "Line" : 31,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# This utility macro extracts the first argument from the list of\n\n# arguments given, and places it into the variable named var.\n\n#\n\n#   car(var arg1 arg2 ...)\n",
        "Line" : 49,
        "CharPositionInLine" : 0
      },
      "4" : {
        "Text" : "# This utility macro extracts all of the arguments given except the\n\n# first, and places them into the variable named var.\n\n#\n\n#   car(var arg1 arg2 ...)\n",
        "Line" : 59,
        "CharPositionInLine" : 0
      },
      "5" : {
        "Text" : "# The PARSE_ARGUMENTS macro will take the arguments of another macro and\n\n# define several variables. The first argument to PARSE_ARGUMENTS is a\n\n# prefix to put on all variables it creates. The second argument is a\n\n# list of names, and the third argument is a list of options. Both of\n\n# these lists should be quoted. The rest of PARSE_ARGUMENTS are\n\n# arguments from another macro to be parsed.\n\n#\n\n#     PARSE_ARGUMENTS(prefix arg_names options arg1 arg2...)\n\n#\n\n# For each item in options, PARSE_ARGUMENTS will create a variable with\n\n# that name, prefixed with prefix_. So, for example, if prefix is\n\n# MY_MACRO and options is OPTION1;OPTION2, then PARSE_ARGUMENTS will\n\n# create the variables MY_MACRO_OPTION1 and MY_MACRO_OPTION2. These\n\n# variables will be set to true if the option exists in the command line\n\n# or false otherwise.\n\n#\n\n# For each item in arg_names, PARSE_ARGUMENTS will create a variable\n\n# with that name, prefixed with prefix_. Each variable will be filled\n\n# with the arguments that occur after the given arg_name is encountered\n\n# up to the next arg_name or the end of the arguments. All options are\n\n# removed from these lists. PARSE_ARGUMENTS also creates a\n\n# prefix_DEFAULT_ARGS variable containing the list of all arguments up\n\n# to the first arg_name encountered.\n\n#\n\n# Usage examples:\n\n# ExampleMacro( myLibary SRCDIRS mysrcs TESTDIRS myTests MODULARIZED)\n\n# ExampleMacro( anotherLib )\n\n# ExampleMacro( thirdLib TESTDIRS myTests)\n\n#\n",
        "Line" : 69,
        "CharPositionInLine" : 0
      },
      "6" : {
        "Text" : "# this utility macro sets the given C++ linker flags globally,\n\n# ie all targets will inherit them automatically\n",
        "Line" : 128,
        "CharPositionInLine" : 0
      },
      "7" : {
        "Text" : "##########################################################################\n\n# Boost Utilities                                                        #\n\n##########################################################################\n\n# Copyright (C) 2007 Douglas Gregor <doug.gregor@gmail.com>              #\n\n# Copyright (C) 2007 Troy Straszheim                                     #\n\n#                                                                        #\n\n# Distributed under the Boost Software License, Version 1.0.             #\n\n# See accompanying file LICENSE_1_0.txt or copy at                       #\n\n#   http://www.boost.org/LICENSE_1_0.txt                                 #\n\n##########################################################################\n\n# Macros in this module:                                                 #\n\n#                                                                        #\n\n#   list_contains: Determine whether a string value is in a list.        #\n\n#                                                                        #\n\n#   car: Return the first element in a list                              #\n\n#                                                                        #\n\n#   cdr: Return all but the first element in a list                      #\n\n#                                                                        #\n\n#   parse_arguments: Parse keyword arguments for use in other macros.    #\n\n##########################################################################\n",
        "Line" : 140,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 8
    }
  },
  "FileTypes" : {
    "CMAKE" : 20,
    "MAKEFILE" : 2
  },
  "ElapsedTime" : 1978
}