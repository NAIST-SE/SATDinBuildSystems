{
  "Repository" : "71270328",
  "Revision" : "HEAD",
  "ObjectId" : "812500eed8875557133f04a566e779bd4f9b2dfc",
  "CommitTime" : "2019-04-17T00:11:34Z",
  "Files" : {
    "fs_image/buck/artifacts_require_repo.bzl" : {
      "ObjectId" : "c007017d42137fba8daf1c83c2e1980774525e1e",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "# Some Buck modes build non-portable artifacts that MUST be executed out\n# of the original repo.",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 1
    },
    "fs_image/buck/crc32.bzl" : {
      "ObjectId" : "dc54abcce85e729187b3fccf18d0ead8aa113dbb",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "# Implementation ported from\n#   http://web.mit.edu/freebsd/head/sys/libkern/crc32.c\n#\n# COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or\n# code or tables extracted from it, as desired without restriction.",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# Support for bitwise arithmetic in Skylark is spotty, so reinvent it...\n# The basic data-type is a 32-item list with items that are 0 or 1.\n# Take that, efficiency!\n# It can be serialized to 8-character lowercase hex strings.",
        "Line" : 7,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# We don't have a _to_int version of this since that runs into integer\n# implementation differences among Skylark implementations.",
        "Line" : 47,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# What follows is just a list32 translation of this code:\n#\n#     crc = 0xffffffff\n#     for c in s:\n#         crc = CRC32_TABLE[0xff & (crc ^ ord(c))] ^ (crc >> 8)\n#     return crc ^ 0xffffffff\n#",
        "Line" : 316,
        "CharPositionInLine" : 4
      },
      "4" : {
        "Text" : "# The computation was checked via Python3 `'{:08x}'.format(binascii.crc32(s))`.",
        "Line" : 333,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 5
    },
    "fs_image/buck/defs.bzl" : {
      "ObjectId" : "ae43524c2cde22bbdb18347fb31c63fcce0e1734",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\n    This rule does not build anything useful! Its only job is to inform\n    `buck query`-powered dependency resolvers that `image_*` targets depend\n    on the underlying macros.\n\n    Without these rules, we would not automatically trigger the appropriate\n    builds & tests on changes to the macro code, which would make it easy to\n    accidentally break trunk.\n\n    This should eventually become unnecessary, follow Q10141.\n\n    Future: It'd be great to enforce that `deps` can only refer to rules of\n    type `fake_macro_library`.  I'm not sure how to do that without writing\n    a full-fledged converter, though.\n    \"\"\"",
        "Line" : 4,
        "CharPositionInLine" : 4
      },
      "1" : {
        "Text" : "# The point of this command is to convince Buck that this rule\n# depends on its sources, and the transitive closure of its\n# dependencies.  The output is a recursive hash, so it should change\n# whenever any of the inputs change.",
        "Line" : 25,
        "CharPositionInLine" : 8
      },
      "CommentCount" : 2
    },
    "fs_image/buck/image.bzl" : {
      "ObjectId" : "1d1fc0f21fa4ce22524aa892a7ad18eb9906832d",
      "LastModified" : "2019-03-28T21:21:41Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "# For `host` mounts, `runtime_source` is required to be empty.",
        "Line" : 12,
        "CharPositionInLine" : 12
      },
      "CommentCount" : 1
    },
    "fs_image/buck/image_feature.bzl" : {
      "ObjectId" : "911dfad34d80df81b68d5259c8bade32697a5f8c",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "#!/usr/bin/env python2\n\"\"\"\nDO NOT DEPEND ON THIS TARGET DIRECTLY, except through the `features=` field\nof `image_feature` or `image_layer`.  A direct dependency will not work the\nway you expect, and you will end up with incorrect behavior.\n\n## Composing images using `image_feature`\n\nWhen building regular binaries, one will often link multiple independent\nlibraries that know nothing about one another. Each of those libraries\nmay depend on other libraries, and so forth.\n\nThis ability to **compose** largely uncoupled pieces of functionality is\nan essential tool of a software engineer.\n\n`image_feature` is a way of bringing the same sort of compositionality to\nbuilding filesystem images.\n\nA feature specifies a set of **items**, each of which describes some aspect\n**of a desired end state** for the filesystem.  Examples:\n - A directory must exist.\n - A taraball must be extracted at this location.\n - An RPM must be installed, or must be **ABSENT** from the filesystem.\n - Other `image_feature` that must be installed.\n\nImportantly, the specifications of an `image_feature` are not ordered. They\nare not commands or instructions.  Rather, they are a declaration of what\nshould be true. You can think of a feature as a thunk or callback.\n\nIn order to convert the declaration into action, one makes an `image_layer`.\nRead that target's docblock for more info, but in essence, that will:\n - specify the initial state of the filesystem (aka the parent layer)\n - verify that the features can be applied correctly -- that dependencies\n   are satisfied, that no features provide duplicate paths, etc.\n - install the features in dependency order,\n - capture the resulting filesystem, ready to be used as another parent layer.\n\"\"\"",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# ## Why are `image_feature`s forbidden as dependencies?\n#\n# The long target suffix below exists to discourage people from directly\n# depending on `image_feature`s.  They are not real targets, but rather a\n# language feature to make it easy to compose independent features of\n# container images.\n#\n# A normal Buck target is supposed to produce an output that completely\n# encapsulates the outputs of all of its dependencies (think static\n# linking), so in deciding whether to build a file or use a cached output,\n# Buck will only consider direct dependencies, not transitive ones.\n#\n# In contrast, `image_feature` simply serializes its keyword arguments to\n# JSON.  It does not consume the outputs of its dependencies -- it reads\n# neither regular target outputs, nor the JSONs of the `image_feature`s, on\n# which it depends.\n#\n# By violating Buck semantics, `image_features` creates two problems for\n# targets that might depend on them:\n#\n# 1) Buck will build any target depending on an `image_feature` immediately\n#    upon ensuring that its JSON output exists in the output tree.  It is\n#    possible that the output tree lacks, or contains stale versions of, the\n#    outputs of the targets, on which the `image_feature` itself depends.\n#\n# 2) If the output of a dependency of an `image_feature` changes, this will\n#    cause the feature to rebuild.  However, the output of the `image_feature`\n#    will remain unchanged, and so any target depending on the `image_feature`\n#    will **NOT** get rebuilt.\n#\n# For these reasons, special logic is required to correctly depend on\n# `image_feature` targets.  At the moment, we are not aware of any reason to\n# have direct access to the `image_feature` JSON outputs in any case.  Most\n# users will want to depend on build artifacts that are downstream of\n# `image_feature`, like `image_layer`.\n#\n# Maintainers of this code: please change this string at will, **without**\n# searching the codebase for people who might be referring to it.  They have\n# seen this blob, and they have agreed to have their code broken without\n# warning.  Do not incentivize hacky engineering practices by \"being nice.\"\n# (Caveat: don't change it daily to avoid forcing excessive rebuilds.)",
        "Line" : 50,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "\"\"\"\n\nOur continuous integration system might run different build steps in\ndifferent sandboxes, so the intermediate outputs of `image_feature`s\nmust be cacheable by Buck.  In particular, they must not contain\nabsolute paths to targets.\n\nHowever, to build a dependent `image_layer`, we will need to invoke the\nimage compiler with the absolute paths of the outputs that will comprise\nthe image.\n\nTherefore, we need to (a) record all the targets, for which the image\ncompiler will need absolute paths, and (b) resolve them only in the\nbuild step that invokes the compiler.\n\nThis tagging scheme makes it possible to find ALL such targets in the\noutput of `image_feature` by simply traversing the JSON structure.  This\nseems more flexible and less messy than maintaining a look-aside list of\ntargets whose paths the `image_layer` converter would need to resolve.\n\n\"\"\"",
        "Line" : 96,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# At present, we only accept dicts that carry an inline mount\n# config (identical to the `mountconfig.json` of a mountable\n# target, but without the overhead of having an on-disk target\n# output). These two equivalent examples illustrate the usage:\n#\n#     mounts = {\"/path/to\": image.host_dir_mount(\n#         source = \"/home/banana/rama\",\n#     )}\n#\n#     mounts = [image.host_dir_mount(\n#         mountpoint = \"/path/to\",\n#         source = \"/home/banana/rama\",\n#     )]\n#\n# In the future, we might accept other keys here, e.g. to\n# override mount options or similar.",
        "Line" : 182,
        "CharPositionInLine" : 12
      },
      "4" : {
        "Text" : "# Skylark linters crash on seeing the XOR operator :/",
        "Line" : 234,
        "CharPositionInLine" : 8
      },
      "5" : {
        "Text" : "# The generator may be in a different directory, so make the\n# target path normal to ensure the hashing is deterministic.",
        "Line" : 243,
        "CharPositionInLine" : 12
      },
      "6" : {
        "Text" : "# The `wrap_runtime_deps_as_build_time_deps` docblock explains this:",
        "Line" : 248,
        "CharPositionInLine" : 12
      },
      "7" : {
        "Text" : "# Handles `rpms` being a dict, too",
        "Line" : 312,
        "CharPositionInLine" : 35
      },
      "8" : {
        "Text" : "# $(query_targets ...) omits the current repo/cell name",
        "Line" : 344,
        "CharPositionInLine" : 8
      },
      "9" : {
        "Text" : "# An iterable of directories to make in the image --\n#  - `into_dir` is a image-absolute path, inside which\n#    we should create more directories. It must be created by\n#    another `image_feature` item.\n#  - `path_to_make` is a path relative to `into_dir`, which will be\n#    created.\n# Order is not significant, the image compiler will sort the actions\n# automatically.  Supported formats for the items:\n#  - string: 'image_absolute/path/to/make'\n#  - tuple: ('into/image_absolute/dir', 'path/to/make')\n#  - dict: {'into_dir': '...', 'path_to_make': '...'}",
        "Line" : 356,
        "CharPositionInLine" : 8
      },
      "10" : {
        "Text" : "# An iterable or dictionary of targets that provide in-container\n# mounts of subtrees or files.  Two* syntax variants are allowed:\n#\n#    # Implies the target-specified \"conventional\" mount-point.\n#    mounts = [\n#        \"//path/to:name_of_mount\",\n#        \"//path/to:another_mount_name\",\n#    ],\n#\n#    # Explicit mount-points, overriding whatever the target\n#    # recommends as the default.\n#    mounts = {\n#        \"/mount/point\": \"//path/to:name_of_mount\",\n#        \"/mount/point\": \"//path/to:name_of_mount\",\n#    }\n#\n# Shadowing mountpoints will never be allowed. Additionally, for now:\n#\n#   - The mountpoint must not exist, and is automatically created as\n#     an empty directory or file with root:root ownership.  If\n#     needed, we may add a flag to accept pre-existing empty\n#     mountpoints (`remove_paths` is a workaround).  The motivation\n#     for auto-creating the mountpoint is two-fold:\n#       * This reduces boilerplate in features with `mounts` -- the\n#         properties of the mountpoint don't matter.\n#       * This guarantees the mounpoint is empty.\n#\n#   - Nesting mountpoints is forbidden. If support is ever added,\n#     we should make the intent to nest very explicit (syntax TBD).\n#\n#   - All mounts are read-only.\n#\n# A mount target, roughly, is a JSON blob with a \"type\" string, a\n# \"source\" location interpretable by that type, and a\n# \"default_mountpoint\".  We use targets as mount sources because:\n#\n#   - This allows mounts to be materialized, flexibly, at build-time,\n#     and allows us to provide a cheap \"development time\" proxy for\n#     mounts that might be distributed in a more costly way at\n#     deployment time.\n#\n#   - This allows us Buck to cleanly cache mounts fetched from\n#     package distribution systems -- i.e.  we can use the local\n#     Buck cache the same way that Docker caches downloaded images.\n#\n# Adding a mount has two side effects on the `image.layer`:\n#   - The mount will be materialized in the `buck-image-out` cache\n#     of the local repo, so your filesystem acts as WYSIWIG.\n#   - The mount will be recorded in `/meta/private/mount`.  PLEASE,\n#     do not rely on this serializaation format for now, it will\n#     change.  That's why it's \"private\".\n#\n# * There is actually a third syntax that is accepted in order to\n#   support helper functions for declaring mounts -- see\n#   `_image_host_mount` for an example.\n#\n# Future: we may need another feature for removing mounts provided\n# by parent layers.",
        "Line" : 368,
        "CharPositionInLine" : 8
      },
      "11" : {
        "Text" : "# An iterable of targets to copy into the image --\n#  - `source` is the Buck target to copy,\n#  - `dest` is an image-absolute path. We follow the `rsync`\n#     convention -- if `dest` ends with a slash, the copy will be at\n#     `dest/output filename of source`.  Otherwise, `dest` is a full\n#     path, including a new filename for the target's output.  The\n#     directory of `dest` must get created by another\n#     `image_feature` item.\n# Order is not signficant, the image compiler will sort the actions\n# automatically.  Supported item formats:\n#  - tuple: ('//target/to/copy', 'image_absolute/dir')\n#  - dict: {'source': '//target/to/copy', 'dest': 'image_absolute/dir'}",
        "Line" : 427,
        "CharPositionInLine" : 8
      },
      "12" : {
        "Text" : "# An iterable of tarballs to extract inside the image.\n#\n# Each item must specify EXACTLY ONE of `tarball`, `generator`:\n#\n#   - EITHER: `tarball`, a Buck target that outputs a tarball.  You\n#     might consider `export_file` or `genrule`.\n#\n#   - OR: `generator`, a path to an executable target, which\n#     will run every time the layer is built.  It is supposed to\n#     generate a deterministic tarball.  The script's contract is:\n#       * Its arguments are the strings from `generator_args`,\n#         followed by one last argument that is a path to an\n#         `image.layer`-provided temporary directory, into which the\n#         generator must write its tarball.\n#       * The generator must print the filename of the tarball,\n#         followed by a single newline, to stdout.  The filename\n#         MUST be relative to the provided temporary directory.\n#\n# In deciding between `tarball` and `generator*`, you are trading\n# off disk space in the Buck cache for the resources (e.g. latency,\n# CPU usage, or network usage) needed to re-generate the tarball.\n# For example, using `generator*` is a good choice when it simply\n# performs a download from a fast immutable blob store.\n#\n# Note that a single script can potentially be used both as a\n# generator, and to produce cached artifacts, see how the compiler\n# test `TARGETS` uses `hello_world_tar_generator.sh` in a genrule.\n#\n# Additionally, every item must contain these keys:\n#   - `hash`, of the format `<python hashlib algo>:<hex digest>`,\n#     which is the hash of the content of the tarball before any\n#     decompression or unpacking.\n#   - `into_dir`, the destination of the unpacked tarball in the\n#     image.  This is an image-absolute path to a directory that\n#     must be created by another `image_feature` item.\n#\n# As with other `image.feature` items, order is not signficant, the\n# image compiler will sort the items automatically.  Tarball items\n# must be dicts -- example:\n#     {\n#         'hash': 'sha256:deadbeef...',\n#         'into_dir': 'image_absolute/dir',\n#         'tarball': '//target/to:extract',\n#     }",
        "Line" : 440,
        "CharPositionInLine" : 8
      },
      "13" : {
        "Text" : "# An iterable of paths to files or directories to (recursively)\n# remove from the layer.  These are allowed to remove paths\n# inherited from the parent layer, or those installed by RPMs even\n# in this layer.  However, removing other items explicitly added by\n# the current layer is currently not supported since that seems like\n# a design smell -- you should probably refactor the constituent\n# `image.feature`s not to conflict with each other.\n#\n# By default, it is an error if the specified paths are missing from\n# the image.  This form is also supported:\n#     [('/path/to/remove', 'assert_exists|if_exists')],\n# which allows you to explicitly ignore missing paths.",
        "Line" : 485,
        "CharPositionInLine" : 8
      },
      "14" : {
        "Text" : "# An iterable of RPM package names to install, **without** version\n# or release numbers.  Order is not significant.  Also supported:\n# {'package-name': 'install|remove_if_exists'}.  Note that removals\n# may only be applied against the parent layer -- if your current\n# layer includes features both removing and installing the same\n# package, this will cause a build failure.",
        "Line" : 498,
        "CharPositionInLine" : 8
      },
      "15" : {
        "Text" : "# An iterable of symlinks to make in the image.  Directories and files\n# are supported independently to provide explicit handling of each\n# source type.  For both `symlinks_to_dirs` and `symlinks_to_files` the\n# following is true:\n#  - `source` is the source file/dir of the symlink.  This file must\n#     exist as we do not support dangling symlinks.\n#  - `dest` is an image-absolute path.  We follow the `rsync`\n#     convention -- if `dest` ends with a slash, the copy will be at\n#     `dest/output filename of source`.  Otherwise, `dest` is a full\n#     path, including a new filename for the target's output.  The\n#     directory of `dest` must get created by another\n#     `image_feature` item.",
        "Line" : 505,
        "CharPositionInLine" : 8
      },
      "16" : {
        "Text" : "# Iterable of `image_feature` targets that are included by this one.\n# Order is not significant.",
        "Line" : 519,
        "CharPositionInLine" : 8
      },
      "17" : {
        "Text" : "\"\"\"Does not make a layer, simply records what needs to be done. A thunk.\"\"\"",
        "Line" : 523,
        "CharPositionInLine" : 4
      },
      "18" : {
        "Text" : "# (1) Normalizes & annotates Buck target names so that they can be\n#     automatically enumerated from our JSON output.\n# (2) Builds a list of targets so that this converter can tell Buck\n#     that the `image_feature` depends on it.",
        "Line" : 525,
        "CharPositionInLine" : 4
      },
      "19" : {
        "Text" : "# noqa: F821\n# Omit the ugly suffix here since this is meant only for\n# humans to read while debugging.",
        "Line" : 531,
        "CharPositionInLine" : 8
      },
      "20" : {
        "Text" : "# It'd be a bit expensive to do any kind of validation of RPM\n# names right here, since we'd need the repo snapshot to decide\n# whether the names are valid, and whether they contain a\n# version or release number.  That'll happen later in the build.",
        "Line" : 541,
        "CharPositionInLine" : 8
      },
      "21" : {
        "Text" : "# Serialize the arguments and defer our computation until\n# build-time.  This allows us to automatically infer what is\n# provided by RPMs & TARs, and makes the implementation easier.\n#\n# Caveat: if the serialization exceeds the kernel's MAX_ARG_STRLEN,\n# this will fail (128KB on the Linux system I checked).\n#\n# TODO: Print friendlier error messages on user error.",
        "Line" : 554,
        "CharPositionInLine" : 4
      },
      "22" : {
        "Text" : "# The constant declaration explains the reason for the name change.",
        "Line" : 563,
        "CharPositionInLine" : 8
      },
      "23" : {
        "Text" : "# For queries",
        "Line" : 566,
        "CharPositionInLine" : 33
      },
      "24" : {
        "Text" : "# We need to tell Buck that we depend on these targets, so\n# that `image_layer` can use `deps()` to discover its\n# transitive dependencies.\n#\n# This is a little hacky, because we are forcing these\n# targets to be built or fetched from cache even though we\n# don't actually use them until a later build step --- which\n# might be on a different host.\n#\n# Future: Talk with the Buck team to see if we can eliminate\n# this inefficiency.",
        "Line" : 568,
        "CharPositionInLine" : 12
      },
      "25" : {
        "Text" : "# Add on a self-dependency (see `fake_macro_library` doc)",
        "Line" : 582,
        "CharPositionInLine" : 16
      },
      "CommentCount" : 26
    },
    "fs_image/buck/image_layer.bzl" : {
      "ObjectId" : "ed1038a9c0ea7a9d6309d15c75b2d5511cb9cc23",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\nAn `image_layer` is an `image_feature` with some additional parameters.  Its\npurpose to materialize that `image_feature` as a btrfs subvolume in the\nper-repo `buck-image/out/volume/targets`.\n\nWe call the subvolume a \"layer\" because it can be built on top of a snapshot\nof its `parent_layer`, and thus can be represented as a btrfs send-stream for\nmore efficient storage & distribution.\n\nThe Buck output of an `image_layer` target is a JSON file with information\non how to find the resulting layer in the per-repo\n`buck-image/out/volume/targets`.  See `SubvolumeOnDisk.to_json_file`.\n\n## Implementation notes\n\nThe implementation of this converter deliberately minimizes the amount of\nbusiness logic in its command.  The converter must include **only** our\ninteractions with the buck target graph.  Everything else should be\ndelegated to subcommands.\n\n### Command\n\nIn composing the `bash` command, our core maxim is: make it a hermetic\nfunction of the converter's inputs -- do not read data from disk, do not\ninsert disk paths into the command, do not do anything that might cause the\nbytes of the command to vary between machines or between runs.  To achieve\nthis, we use Buck macros to resolve all paths, including those to helper\nscripts.  We rely on environment variables or pipes to pass data between the\nhelper scripts.\n\nAnother reason to keep this converter minimal is that `buck test` cannot\nmake assertions about targets that fail to build.  Since we only have the\nability to test the \"good\" targets, it behooves us to put most logic in\nexternal scripts, so that we can unit-test its successes **and** failures\nthoroughly.\n\n### Output\n\nWe mark `image_layer` uncacheable, because there's no easy way to teach Buck\nto serialize a btrfs subvolume (for that, we have `image_layer_sendstream`).\nThat said, we should still follow best practices to avoid problems if e.g.\nthe user renames their repo, or similar.  These practices include:\n  - The output JSON must store no absolute paths.\n  - Store Buck target paths instead of paths into the output directory.\n\n### Dependency resolution\n\nAn `image_layer` consumes `image_feature` outputs to decide what to put into\nthe btrfs subvolume.  These outputs are actually just JSON files that\nreference other targets, and do not contain the data to be written into the\nimage.\n\nTherefore, `image_layer` has to explicitly tell buck that it needs all\ndirect dependencies of its `image_feature`s to be present on disk -- see our\n`attrfilter` queries below.  Without this, Buck would merrily fetch the just\nthe `image_feature` JSONs from its cache, and not provide us with any of the\nbuid artifacts that comprise the image.\n\nWe do NOT need the direct dependencies of the parent layer's features,\nbecause we treat the parent layer as a black box -- whatever it has laid\ndown in the image, that's what it provides (and we don't care about how).\nThe consequences of this information hiding are:\n\n  - Better Buck cache efficiency -- we don't have to download\n    the dependencies of the ancestor layers' features. Doing that would be\n    wasteful, since those bits are redundant with what's in the parent.\n\n  - Ability to use foreign image layers / apply non-pure post-processing to\n    a layer.  In terms of engineering, both of these non-pure approaches are\n    a terrible idea and a maintainability headache, but they do provide a\n    useful bridge for transitioning to Buck image builds from legacy\n    imperative systems.\n\n  - The image compiler needs a litte extra code to walk the parent layer and\n    determine what it provides.\n\n  - We cannot have \"unobservable\" dependencies between features.  Since\n    feature dependencies are expected to routinely cross layer boundaries,\n    feature implementations are forced only to depend on data that can be\n    inferred from the filesystem -- since this is all that the parent layer\n    implementation can do.  NB: This is easy to relax in the future by\n    writing a manifest with additional metadata into each layer, and using\n    that metadata during compilation.\n\"\"\"",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# The name of another `image_layer` target, on top of which the\n# current layer will install its features.",
        "Line" : 109,
        "CharPositionInLine" : 8
      },
      "2" : {
        "Text" : "# Future: should we determine this dynamically from the installed\n# artifacts (by totaling up the bytes needed for copied files, RPMs,\n# tarballs, etc)?  NB: At the moment, this number doesn't work\n# precisely as a user would want -- we just require that the base\n# volume have at least this much space, -- but hopefully people\n# don't have to change it too much.\n# The string is used instead of int because build language supports\n# only 32-bit integer values.",
        "Line" : 112,
        "CharPositionInLine" : 8
      },
      "3" : {
        "Text" : "# Path to a binary target, with this CLI signature:\n#   yum_from_repo_snapshot --install-root PATH -- SOME YUM ARGS\n# Required if any dependent `image_feature` specifies `rpms`.",
        "Line" : 122,
        "CharPositionInLine" : 8
      },
      "4" : {
        "Text" : "# Path to a target outputting a btrfs send-stream of a subvolume;\n# mutually exclusive with using any of the image_feature fields.",
        "Line" : 126,
        "CharPositionInLine" : 8
      },
      "5" : {
        "Text" : "# The name of the btrfs subvolume to create.",
        "Line" : 129,
        "CharPositionInLine" : 8
      },
      "6" : {
        "Text" : "# Layers can be used in the `mounts` field of an `image.feature`.\n# This setting affects how **this** layer may be mounted inside\n# others.\n#\n# The default mount config for a layer only provides a\n# `build_source`, specifying how the layer should be mounted at\n# development time inside the in-repo `buck-image-out` subtree.\n#\n# This argument can set `runtime_source` and `default_mountpoint`.\n# The former is essential -- to get a layer from `mounts` to be\n# mounted at container run-time, we have to tell the container agent\n# how to obtain the layer-to-be-mounted.  This can be done in a\n# variety of ways, so it's not part of `image.layer` itself, and\n# must be set from outside.",
        "Line" : 131,
        "CharPositionInLine" : 8
      },
      "7" : {
        "Text" : "# There are two independent ways to populate the resulting btrfs\n# subvolume: (i) set `from_sendstream` and nothing else, (ii) set other\n# arguments as desired.  These modes live in a single target type for\n# memorability, and because much of the implementation is shared.",
        "Line" : 154,
        "CharPositionInLine" : 4
      },
      "8" : {
        "Text" : "# Mechanistically, applying a send-stream on top of an\n# existing layer is just a regular `btrfs receive`.\n# However, the rules in the current `receive` implementation\n# for matching the parent to the stream are kind of awkward,\n# and it's not clear whether they are right for us in Buck.",
        "Line" : 165,
        "CharPositionInLine" : 12
      },
      "9" : {
        "Text" : "# The compiler knows how to resolve layer locations.  For now, we\n# don't support mounting a subdirectory of a layer because that\n# might make packaging more complicated, but it could be done.",
        "Line" : 208,
        "CharPositionInLine" : 8
      },
      "10" : {
        "Text" : "# To make layers \"image-mountable\", provide `mountconfig.json`.",
        "Line" : 284,
        "CharPositionInLine" : 16
      },
      "11" : {
        "Text" : "# Layers are only usable on the same host that built them, so\n# keep our output JSON out of the distributed Buck cache.  See\n# the docs for BuildRule::isCacheable.",
        "Line" : 295,
        "CharPositionInLine" : 8
      },
      "12" : {
        "Text" : "# For queries",
        "Line" : 299,
        "CharPositionInLine" : 43
      },
      "13" : {
        "Text" : "# For ease of use, a layer takes all the arguments of a feature, so\n# just make an implicit feature target to implement this.",
        "Line" : 310,
        "CharPositionInLine" : 4
      },
      "14" : {
        "Text" : "# We will ask Buck to ensure that the outputs of the direct dependencies\n# of our `image_feature`s are available on local disk.\n#\n# See `Implementation notes: Dependency resolution` in `__doc__` -- note\n# that we need no special logic to exclude parent-layer features, since\n# this query does not traverse them anyhow.",
        "Line" : 320,
        "CharPositionInLine" : 4
      },
      "15" : {
        "Text" : "# We have two layers of quoting here.  The outer '' groups the query\n# into a single argument for `query_targets_and_outputs`.  The inner\n# \"\" allows = and a few other special characters to be used in layer\n# target names.\n\"\"\"$(query_targets_and_outputs 'deps(\"\"\"\n\"\"\"attrfilter(type, image_feature, deps(\"{}\"))\"\"\"\n\"\"\", 1)')\"\"\"",
        "Line" : 327,
        "CharPositionInLine" : 8
      },
      "16" : {
        "Text" : "# In terms of **dependency** structure, we want this\n# to be `exe` (see `image_package.py` for why).\n# However the string output of the `exe` macro may\n# actually be a shell snippet, which would break\n# here.  To work around this, we add a no-op $(exe)\n# dependency via `maybe_yum_from_repo_snapshot_dep`.",
        "Line" : 363,
        "CharPositionInLine" : 12
      },
      "17" : {
        "Text" : "# Ensure that the layer directly depends on the yum target.",
        "Line" : 375,
        "CharPositionInLine" : 12
      },
      "CommentCount" : 18
    },
    "fs_image/buck/image_package.bzl" : {
      "ObjectId" : "fcf2bd7dc95077ae1cfca4d39e9543e89ac1420f",
      "LastModified" : "2019-03-26T04:29:48Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\nThe `image_package` rule serializes an `image_layer` target into one or more\nfiles, as described by the specified `format`.\n\"\"\"",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# Standard naming: <image_layer_name>.<package_format>.\n#\n# For supported formats, see `--format` here:\n#\n#     buck run :package-image -- --help\n#\n# If you are packaging an `image_layer` from a different TARGETS\n# file, then pass `layer =`, and specify whatever name you want.",
        "Line" : 15,
        "CharPositionInLine" : 8
      },
      "2" : {
        "Text" : "# If possible, do not set this. Prefer the standard naming convention.",
        "Line" : 24,
        "CharPositionInLine" : 8
      },
      "3" : {
        "Text" : "# For queries",
        "Line" : 44,
        "CharPositionInLine" : 43
      },
      "4" : {
        "Text" : "# We don't need to hold any subvolume lock because we trust\n# that (a) Buck will keep our input JSON alive, and (b) the\n# existence of the JSON will keep the refcount above 1,\n# preventing any concurrent image builds from\n# garbage-collecting the subvolumes.",
        "Line" : 47,
        "CharPositionInLine" : 12
      },
      "5" : {
        "Text" : "# Future: When adding support for incremental outputs,\n# use something like this to obtain all the ancestors,\n# so that the packager can verify that the specified\n# base for the incremental computation is indeed an\n# ancestor:\n#     --ancestor-jsons $(query_outputs \"attrfilter( \\\n#       type, image_layer, deps({layer}))\")\n# This could replace `--subvolume-json`, though also\n# specifying it would make `get_subvolume_on_disk_stack`\n# more efficient.",
        "Line" : 67,
        "CharPositionInLine" : 16
      },
      "6" : {
        "Text" : "# We are not writing to the volume.",
        "Line" : 78,
        "CharPositionInLine" : 40
      },
      "CommentCount" : 7
    },
    "fs_image/buck/image_python_unittest.bzl" : {
      "ObjectId" : "c1e82ed8d9f6aa57f5ad62f5c9941e9513a5c337",
      "LastModified" : "2019-03-28T21:21:41Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "# `par_style` only applies to the inner test that runs the actual user\n# code, because there is only one working choice for the outer test.\n# For the inner test:\n#   - Both `zip` and `fastzip` are OK, but the latter is the default\n#     since it should be more kind to `/tmp` `tmpfs` memory usage.\n#   - XAR fails to work for tests that run unprivileged (the default)\n#     My quick/failed attempt to fix this is in P61015086, but we'll\n#     probably be better off adding support for copying python trees\n#     directly into the image in preference to fixing XAR.",
        "Line" : 19,
        "CharPositionInLine" : 4
      },
      "1" : {
        "Text" : "# People who need to access the filesystem will have to set \"zip\",\n# but that'll cost more RAM to run since nspawn `/tmp` is `tmpfs`.",
        "Line" : 29,
        "CharPositionInLine" : 8
      },
      "2" : {
        "Text" : "# Some `python_unittest` kwargs need to be set on the wrapper instead\n# of the actual test (to be wrapped).",
        "Line" : 39,
        "CharPositionInLine" : 4
      },
      "3" : {
        "Text" : "# This is the test binary that is supposed to run inside the image.  The\n# \"IGNORE-ME\" prefix serves to inform users who come across this target\n# that this is not the test binary they are looking for.  It's a prefix\n# to avoid people stumbling across it via tab-completion.",
        "Line" : 46,
        "CharPositionInLine" : 4
      },
      "4" : {
        "Text" : "# These tags (aka labels) are a defense-in-depth attempt to make the\n# un-wrapped test never get executed by the test runner.",
        "Line" : 53,
        "CharPositionInLine" : 8
      },
      "5" : {
        "Text" : "# In `.buckconfig`, we have a line that asks Buck not to report\n# this test to the test runner if it's only being pulled in as a\n# transitive dependency:\n#\n#   [test]\n#     excluded_labels = exclude_test_if_transitive_dep\n#\n# This means that with `buck test //path:name`, the test runner\n# would never see IGNORE-ME tests.",
        "Line" : 56,
        "CharPositionInLine" : 12
      },
      "6" : {
        "Text" : "# Buck will still report the test to the test runner if the\n# user runs `buck test path/...`, which is a common pattern.\n# This tag tells the FB test runner NOT to run this test, nor to\n# show it as OMITTED.",
        "Line" : 66,
        "CharPositionInLine" : 12
      },
      "7" : {
        "Text" : "# For peace of mind, add classic test-runner tags that are\n# mutually incompatible, and would essentially always cause the\n# test to be marked OMITTED even if the prior two tags were\n# somehow ignored.",
        "Line" : 71,
        "CharPositionInLine" : 12
      },
      "8" : {
        "Text" : "# The build-time -> run-time dependency wrapper doesn't work inside\n# @mode/opt containers, since those (deliberately) don't bind-mount the\n# repo inside.  They are supposed to be self-contained and ready for\n# production.\n#\n# However, in @mode/opt we don't care about the build-time / run-time\n# dependency problem since C++ & Python build artifacts are\n# self-contained, making the two dependency types identical.\n#\n# # NB: This check here causes the target graphs to be subtly different\n# between @mode/dev and @mode/opt.  I don't expect this to cause\n# problems for CI, however, because this internal target shouldn't have\n# any semantics for our test or build infrastructure.",
        "Line" : 87,
        "CharPositionInLine" : 4
      },
      "9" : {
        "Text" : "# NB: Anything that includes the wrapped target output must be marked\n# uncacheable.  At the moment, this is only the `image_layer`, which\n# always sets `cacheable = False` anyway.",
        "Line" : 102,
        "CharPositionInLine" : 8
      },
      "10" : {
        "Text" : "# Make a test-specific image containing the test binary.",
        "Line" : 112,
        "CharPositionInLine" : 4
      },
      "11" : {
        "Text" : "# This target name gets a suffix to keep it discoverable via tab-completion",
        "Line" : 115,
        "CharPositionInLine" : 4
      },
      "12" : {
        "Text" : "# Generate a `.py` file that sets some of the key container options.",
        "Line" : 124,
        "CharPositionInLine" : 4
      },
      "13" : {
        "Text" : "# An inane comment on how Buildifier formatting is terrible",
        "Line" : 135,
        "CharPositionInLine" : 16
      },
      "14" : {
        "Text" : "# The `.py` file with container options must be in its own library\n# because the base_module of `nspawn_test_in_subvol.py` is empty, and\n# this library allows us to place the packaged spec file (and layer) at\n# the root of the source archive.  That makes the much easier to for\n# `nspawn_test_in_subvol` to discover than if it had to contend with a\n# user-supplied `base_module` as is set on the `name` target.",
        "Line" : 142,
        "CharPositionInLine" : 4
      },
      "15" : {
        "Text" : "# `nspawn_test_in_subvol` knows to look for this file in the archive.",
        "Line" : 153,
        "CharPositionInLine" : 8
      },
      "16" : {
        "Text" : "# This **has** to be a `python_unittest` (as opposed to e.g. a `sh_test`\n# with the right `labels`) so that `needed_coverage` works as expected.\n# Moreover, it's overall cleaner to make the wrapper be the same rule\n# type as the wrapped test.",
        "Line" : 158,
        "CharPositionInLine" : 4
      },
      "17" : {
        "Text" : "# Allow CI determinators to discover that tests need to be\n# rebuilt if this .bzl file changes.",
        "Line" : 165,
        "CharPositionInLine" : 12
      },
      "18" : {
        "Text" : "# NB: It's possible to use `env` to pass the arguments and the\n# location of the test layer to the driver binary.  However,\n# this would prevent one from running the test binary directly,\n# bypassing Buck.  Since Buck CLI is slow, this would be a\n# significant drop in usability, so we use this library trick.",
        "Line" : 171,
        "CharPositionInLine" : 12
      },
      "19" : {
        "Text" : "# Ensures we can read resources in @mode/opt.  \"xar\" cannot work\n# because `root` cannot access the content of unprivileged XARs.",
        "Line" : 179,
        "CharPositionInLine" : 8
      },
      "CommentCount" : 20
    },
    "fs_image/buck/image_utils.bzl" : {
      "ObjectId" : "f88c531cb9719124c76b2e46beb452afe69be79a",
      "LastModified" : "2019-03-28T21:21:41Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\n    # CAREFUL: To avoid inadvertently masking errors, we should\n    # only perform command substitutions with variable\n    # assignments.\n    set -ue -o pipefail\n\n    # Ensures that changes to the sources of the rule macros cause automatic\n    # builds & tests on the artifacts they produce.\n    echo $(location {self_dependency}) > /dev/null\n\n    start_time=\\\\$(date +%s)\n    # Common sense would tell us to find helper programs via:\n    #   os.path.dirname(os.path.abspath(__file__))\n    # The benefit of using \\\\$(exe) is that it does not bake an absolute\n    # paths into our command.  This means the Buck cache continues working\n    # even if the user moves the repo.  `exe` vs `location` is explained in\n    # `image_package.bzl`.  We need `binary_path` because the `exe` macro\n    # won't get expanded inside a \\\\$( ...  ) context.\n    binary_path=( $(exe //fs_image:artifacts-dir) )\n    artifacts_dir=\\\\$( \"${{binary_path[@]}}\" )\n\n    # Future-proofing: keep all Buck target subvolumes under\n    # \"targets/\" in the per-repo volume, so that we can easily\n    # add other types of subvolumes in the future.\n    binary_path=( $(exe //fs_image:volume-for-repo) )\n    volume_dir=\\\\$( \"${{binary_path[@]}}\" \"$artifacts_dir\" {min_free_bytes} )\n    subvolumes_dir=\"$volume_dir/targets\"\n    mkdir -m 0700 -p \"$subvolumes_dir\"\n\n    # Capture output to a tempfile to hide logspam on successful runs.\n    my_log=`mktemp`\n\n    log_on_error() {{\n      exit_code=\"$?\"\n      # Always persist the log for debugging purposes.\n      collected_logs=\"$artifacts_dir/image_build.log\"\n      (\n          echo \"\\n\\\\$(date) --\" \\\n            \"\\\\$(($(date +%s) - start_time)) sec --\" \\\n            \"{log_description}\\n\"\n          cat \"$my_log\" || :\n      ) |& flock \"$collected_logs\" tee -a \"$collected_logs\"\n      # If we had an error, also dump the log to stderr.\n      if [[ \"$exit_code\" != 0 ]] ; then\n        cat \"$my_log\" 1>&2\n      fi\n      rm \"$my_log\"\n    }}\n    # Careful: do NOT replace this with (...) || (...), it will lead\n    # to `set -e` not working as you expect, because bash is awful.\n    trap log_on_error EXIT\n\n    (\n      # Log all commands now that stderr is redirected.\n      set -x\n\n      {bash}\n\n      # It is always a terrible idea to mutate Buck outputs after creation.\n      # We have two special reasons that make it even more terrible:\n      #  - [image_layer] Uses a hardlink-based refcounting scheme, as\n      #    and keeps subvolumes in a special location.\n      #  - [image_package] Speeds up the build for the `sendstream_stack`\n      #    format by hardlinking duplicated outputs between targets.\n      #\n      # Not using \"chmod -R\" since Buck cleanup is fragile and cannot handle\n      # read-only directories.\n      find \"$OUT\" '!' -type d -print0 | xargs -0 --no-run-if-empty chmod a-w\n    ) &> \"$my_log\"\n    \"\"\"",
        "Line" : 6,
        "CharPositionInLine" : 11
      },
      "CommentCount" : 1
    },
    "fs_image/buck/wrap_runtime_deps.bzl" : {
      "ObjectId" : "4d9efc2190796ff24a3011ca5eb9b0b08cdf268d",
      "LastModified" : "2019-03-28T21:21:41Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\n    Wraps the `target` with a new target in the current project named `name`\n    to convert its run-time dependencies to build-time dependencies.\n\n    IMPORTANT: The resulting artifact is NOT cacheable, so if you include\n    its contents in some other artifact, that artifact must ALSO become\n    non-cacheable.\n\n    This is used when `image.layer` will run `target` as part of its build\n    process, or when some target needs to be executable from inside an\n    `image.layer`.\n\n    The reason for this is that due to Buck limitations, `image.layer`\n    cannot directly take on runtime dependencies (more on that below), so\n    the wrapper does that for us.\n\n    Here is what would go wrong if we just passed `target` directly to\n    `image.layer`.\n\n     - For concreteness' sake, let's say that `target` needs to be\n       executed by the `image.layer` build script (as is the case for\n       `generator` from `tarballs`).\n\n     - `image.layer` will use $(query_targets_and_outputs) to find the\n       output path for `target`.\n\n     - Suppose that `target`'s source code CHANGED since the last time our\n       layer was built.\n\n     - Furthermore, suppose that the output of `target` is a thin wrapper,\n       such as what happens with in-place Python executables in @mode/dev.\n       Even though the FUNCTIONALITY of the Python executable has changed,\n       the actual build output will remain the same.\n\n     - At this point, the output path that's included in the bash command of\n       the layer's genrule has NOT changed.  The file referred to by that\n       output path has NOT changed.  Only its run-time dependencies (the\n       in-place symlinks to the actual `.py` files) have changed.\n       Therefore, as far as build-time dependencies of the layer are\n       concerned, the layer does not need to re-build: the inputs of the\n       layer genrule are bitwise the same as the inputs before any changes\n       to `target`'s source code.\n\n       In other words, although `target` itself WOULD get rebuilt due to\n       source code changes, the layer that depends on that target WOULD NOT\n       get rebuilt, because it does not consider the `.py` files inside the\n       in-place Python link-tree to be build-time inputs.  Those are runtime\n       dependencies.  Peruse the docs here for a Buck perspective:\n           https://github.com/facebook/buck/blob/master/src/com/facebook/\n           buck/core/rules/attr/HasRuntimeDeps.java\n\n    We could avoid the wrapper if we could add `target` as a **runtime\n    dependency** to the `image.layer` genrule.  However, Buck does not make\n    this possible.  It is possible to add runtime dependencies on targets\n    that are KNOWN to the `image.layer` macro at parse time, since one could\n    then use `$(exe)` -- which says \"rebuild me if the mentioned target's\n    runtime dependencies have changed\".  But because we want to support\n    composition of layers via features, `$(exe)` does not help -- the layer\n    has to discover its features' dependencies via a query.  Unfortunately,\n    Buck's query facilities of today only allow making build-time\n    dependencies (not runtime dependencies).  So supporting the right API\n    would require a change in Buck.  Either of these would do:\n\n      - Support adding query-determined runtime dependencies to\n        genrules -- via a special-purpose macro, a macro modifier, or a rule\n        attribute.\n\n      - Support Bazel-style providers, which would let the layer\n        implementation directly access the data collated by its features.\n        Then, the layer could just issue $(exe) macros for all runtime-\n        dependency targets.  NB: This would bring a build speed win, too.\n    \"\"\"",
        "Line" : 5,
        "CharPositionInLine" : 4
      },
      "1" : {
        "Text" : "# We deliberately generate a unique output on each rebuild.",
        "Line" : 89,
        "CharPositionInLine" : 8
      },
      "CommentCount" : 2
    },
    "fs_image/compiler/defs.bzl" : {
      "ObjectId" : "4c790bdcc4164c7d9ebeb7075099b801cfbbc28a",
      "LastModified" : "2019-03-28T21:21:41Z",
      "FileType" : "BAZEL",
      "0" : {
        "Text" : "\"\"\"\n    DANGER: If you depend on a feature target for testing, you MUST manually\n    add any `image_feature` targets that it depends on to your `deps = []`.\n    If you fail to do this, Buck will not know to rebuild the the test if\n    one of its indirect `image_feature` dependencies changes.  See\n    `image_feature.py` for an explanation.\n    \"\"\"",
        "Line" : 6,
        "CharPositionInLine" : 4
      },
      "1" : {
        "Text" : "# TODO: Just use a proper visibility rule?",
        "Line" : 14,
        "CharPositionInLine" : 4
      },
      "2" : {
        "Text" : "# For now cpp_deps is raw buck deps for python_ targets",
        "Line" : 29,
        "CharPositionInLine" : 4
      },
      "3" : {
        "Text" : "# The test reads `feature.json`, so we need actual files on disk.",
        "Line" : 37,
        "CharPositionInLine" : 8
      },
      "CommentCount" : 4
    }
  },
  "FileTypes" : {
    "BAZEL" : 11
  },
  "ElapsedTime" : 1950
}