{
  "Repository" : "13724879",
  "Revision" : "HEAD",
  "ObjectId" : "9ad981c3513bf7cc8d866000681be7d158b6953b",
  "CommitTime" : "2019-04-16T23:36:45Z",
  "Files" : {
    "CMakeLists.txt" : {
      "ObjectId" : "f521a8d80010e09c46cebbb348c6db0502aa91f1",
      "LastModified" : "2019-04-04T20:13:36Z",
      "FileType" : "CMAKE",
      "0" : {
        "Text" : "# To use CMake to build SLiM, create a new subdirectory alongside your source directory (assumed here\n\n# to be named SLiM), e.g., \"build\", then run the following commands:\n\n#\n\n#   cd build\n\n#   cmake ../SLiM\n\n#   make\n\n#\n\n# This will make a Release build, with optimization and without debugging symbols, by default.\n\n# The built executables will be placed in the build directory upon successful completion.\n\n# \n\n# You can also explicitly make a Release build; this is typically done in a directory named \"Release\"\n\n# instead of \"build\":\n\n#\n\n#   mkdir Release\n\n#   cd Release\n\n#   cmake -D CMAKE_BUILD_TYPE=Release ../SLiM\n\n#   make\n\n#\n\n# Or you can make a Debug build (without optimization, with debugging symbols):\n\n#\n\n#   mkdir Debug\n\n#   cd Debug\n\n#   cmake -D CMAKE_BUILD_TYPE=Debug ../SLiM\n\n#   make\n\n#\n\n# In all cases the concept is the same: make a build directory of some name, cd into it, run cmake\n\n# to set up the build (with a CMAKE_BUILD_TYPE flag if desired, otherwise Release will be used by\n\n# default), then run make to actually do the build.  This setup (1) keeps all build products out of\n\n# your source tree, which is generally a good idea, and (2) allows you to have both Release and\n\n# Debug builds going simultaneously.\n\n#\n\n# You can do \"make VERBOSE=1\" instead of just \"make\" to see the full command lines used.  There are\n\n# also various targets defined by cmake for make, such as \"slim\", \"eidos\", \"clean\", \"all\", etc.  To\n\n# rebuild all of cmake's internal caches etc. (which is generally a good idea after a \"git pull\",\n\n# for example, or after the addition or removal of source files), the simplest thing is generally\n\n# to touch the CMakeLists.txt file in the source tree top-level directory:\n\n#\n\n#   touch ../SLiM/CMakeLists.txt\n\n#\n\n# Then you can just do \"make\"; cmake will automatically be re-run by make since the CMakeLists.txt\n\n# file has changed.\n",
        "Line" : 1,
        "CharPositionInLine" : 0
      },
      "1" : {
        "Text" : "# Make a Release build by default\n",
        "Line" : 47,
        "CharPositionInLine" : 0
      },
      "2" : {
        "Text" : "# Use the flags below for [all / Debug / Release] builds; these flags are built in to cmake\n",
        "Line" : 52,
        "CharPositionInLine" : 0
      },
      "3" : {
        "Text" : "# Report the build type\n",
        "Line" : 62,
        "CharPositionInLine" : 0
      },
      "4" : {
        "Text" : "# Test for -flto support\n\n# BCH 4/4/2019: I am disabling this LTO stuff for now.  It made only a very small performance\n\n# difference, and multiple users reported build problems associated with it (see Issue #33).\n\n#include(CheckCXXCompilerFlag)\n\n#include(CheckCCompilerFlag)\n\n#CHECK_CXX_COMPILER_FLAG(-flto CXX_SUPPORTS_FLTO)\n\n#CHECK_C_COMPILER_FLAG(-flto C_SUPPORTS_FLTO)\n\n#if(CXX_SUPPORTS_FLTO AND C_SUPPORTS_FLTO)\n\n#    message(STATUS \"Compiling with FLTO support\")\n\n#    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -flto\")\n\n#    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -flto\")\n\n#    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -flto\")\n\n#endif()\n",
        "Line" : 65,
        "CharPositionInLine" : 0
      },
      "5" : {
        "Text" : "# GSL \n",
        "Line" : 79,
        "CharPositionInLine" : 0
      },
      "6" : {
        "Text" : "# KASTORE\n",
        "Line" : 86,
        "CharPositionInLine" : 0
      },
      "7" : {
        "Text" : "# TSKIT\n",
        "Line" : 93,
        "CharPositionInLine" : 0
      },
      "CommentCount" : 8
    }
  },
  "FileTypes" : {
    "CMAKE" : 1
  },
  "ElapsedTime" : 1768
}